name: "Issue â†’ PR: Add Member"

on:
  issues:
    types: [opened, edited, reopened]

jobs:
  from-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure 'members' label (if issue looks like member form)
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (!issue || issue.state !== 'open') return;
            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const body = issue.body || '';
            const looksLikeForm = /Full name/i.test(body) && /(Image URL|repo path|image\s*:)/i.test(body);
            if (!labels.includes('members') && looksLikeForm) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['members']
              });
            }

      - name: Parse issue form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';

            // Try to parse a fenced YAML block first (most robust)
            let yamlBlock;
            {
              const m = body.match(/```yaml[\s\S]*?```/i);
              if (m) {
                yamlBlock = m[0].replace(/```yaml/i, '').replace(/```\s*$/i, '').trim();
              }
            }
            const data = {};
            if (yamlBlock) {
              const lines = yamlBlock.split(/\r?\n/);
              for (const line of lines) {
                const mm = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*"?(.*?)"?\s*$/);
                if (mm) data[mm[1].toLowerCase()] = mm[2];
              }
            }

            // Helper to build a map of headings â†’ content
            const headingMap = {};
            if (!data.name || !data.image) {
              const lines = body.split(/\r?\n/);
              let current = null; let buf = [];
              const flush = () => { if (current) { headingMap[current.toLowerCase()] = buf.join('\n').trim(); buf = []; } };
              for (const line of lines) {
                const h = line.match(/^\s*#{1,6}\s*(.*?)\s*$/);
                if (h) { flush(); current = h[1]; continue; }
                if (current) buf.push(line);
              }
              flush();
            }

            const fromHeadings = (needles) => {
              for (const [k, v] of Object.entries(headingMap)) {
                const lower = k.toLowerCase();
                if (needles.some(n => lower.includes(n))) return (v || '').trim();
              }
              return '';
            };
            const extractInline = (key) => {
              const m = body.match(new RegExp(`(^|\\r?\\n)\\s*${key}\\s*:\\s*(.+)`, 'i'));
              return m ? m[2].trim() : '';
            };

            const lower = (s) => (s || '').toLowerCase();
            let name = data.name || fromHeadings(['full name','name']) || extractInline('name');
            let role = data.role || fromHeadings(['role']) || extractInline('role');
            let affiliation = data.affiliation || fromHeadings(['affiliation']) || extractInline('affiliation');
            let image = data.image || fromHeadings(['image url','image','repo path']) || extractInline('image');
            let website = data.website || fromHeadings(['website','profile']) || extractInline('website');
            let order = data.order || fromHeadings(['order','ordering']) || extractInline('order');

            if (!name && context.payload.issue.title) {
              const mt = context.payload.issue.title.match(/Add:\s*(.+)$/i);
              if (mt) name = mt[1].trim();
            }

            if (!name || !image) {
              core.info('Missing required fields: name and/or image. Skipping.');
              core.setOutput('found', 'false');
              return;
            }
            const slugify = (s) => (s || '').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
            let slug = slugify(name);
            if (!slug) { slug = 'user-' + Date.now(); }

            core.setOutput('found', 'true');
            core.setOutput('name', name);
            core.setOutput('role', role || '');
            core.setOutput('affiliation', affiliation || '');
            core.setOutput('image', image);
            core.setOutput('website', website || '');
            core.setOutput('order', order || '');
            core.setOutput('slug', slug);

      - name: Create working branch
        if: steps.parse.outputs.found == 'true'
        run: |
          base="${{ github.event.repository.default_branch }}"
          git checkout -b add-member/${{ steps.parse.outputs.slug }} origin/$base || git checkout -b add-member/${{ steps.parse.outputs.slug }}

      - name: Ensure directories
        if: steps.parse.outputs.found == 'true'
        run: |
          mkdir -p src/content/members src/assets/members

      - name: Download image if URL
        id: dl
        if: steps.parse.outputs.found == 'true'
        run: |
          IMG="${{ steps.parse.outputs.image }}"
          if echo "$IMG" | grep -qi '^http'; then
            # Extract the path from the URL (remove query and fragment)
            path=$(echo "$IMG" | sed -E 's|^[^:/]+://[^/]+||' | cut -d'?' -f1 | cut -d'#' -f1)
            filename=$(basename "$path")
            ext="${filename##*.}"
            if [ "$filename" = "$ext" ]; then ext="jpg"; fi
            out="src/assets/members/${{ steps.parse.outputs.slug }}.$ext"
            curl -L "$IMG" -o "$out"
            echo "path=../../assets/members/$(basename "$out")" >> $GITHUB_OUTPUT
          else
            echo "path=$IMG" >> $GITHUB_OUTPUT
          fi

      - name: Write member file
        if: steps.parse.outputs.found == 'true'
        run: |
          cat > src/content/members/${{ steps.parse.outputs.slug }}.md <<EOF
          ---
          name: "${{ steps.parse.outputs.name }}"
          role: "${{ steps.parse.outputs.role }}"
          affiliation: "${{ steps.parse.outputs.affiliation }}"
          image: "${{ steps.dl.outputs.path }}"
          website: "${{ steps.parse.outputs.website }}"
          order: ${{ steps.parse.outputs.order }}
          tags: ["member"]
          ---
          EOF

      - name: Commit changes
        if: steps.parse.outputs.found == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add src/content/members src/assets/members || true
          git commit -m "chore(members): add ${{ steps.parse.outputs.slug }} via issue" || echo "No changes to commit"

      - name: Push branch
        if: steps.parse.outputs.found == 'true'
        run: |
          git push -u origin HEAD || true

      - name: Open PR
        if: steps.parse.outputs.found == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: add-member/${{ steps.parse.outputs.slug }}
          title: "[Member] Add: ${{ steps.parse.outputs.name }}"
          body: |
            Auto-generated from issue #${{ github.event.issue.number }}.

            <!-- MEMBER-INFO-START -->
            ```yaml
            name: "${{ steps.parse.outputs.name }}"
            role: "${{ steps.parse.outputs.role }}"
            affiliation: "${{ steps.parse.outputs.affiliation }}"
            image: "${{ steps.dl.outputs.path }}"
            website: "${{ steps.parse.outputs.website }}"
            order: ${{ steps.parse.outputs.order }}
            ```
            <!-- MEMBER-INFO-END -->
            
            Closes #${{ github.event.issue.number }}
          labels: members, content
          delete-branch: false


